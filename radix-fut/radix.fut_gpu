Up to date
types {
  
}



entry("step",
      {num_threads: i64,
       e: i64,
       digit: u32,
       arr: *[][]u32},
      {*[][]u32})
  entry_step (num_blocks_7076 : i64,
              num_elems_7077 : i64,
              num_threads_7078 : i64,
              e_7079 : i64,
              digit_7080 : i32,
              arr_7081 : *[num_blocks_7076][num_elems_7077]i32)
  : {*[num_blocks_7076][num_elems_7077]i32} = {
  let {d<{(*) num_threads e}>_8155 : i64} =
    mul64(num_threads_7078, e_7079)
  let {d<{(-) num_threads 1}>_8156 : i64} =
    sub64(num_threads_7078, 1i64)
  let {dim_match_8160 : bool} =
    eq_i64(num_elems_7077, d<{(*) num_threads e}>_8155)
  let {empty_or_match_cert_8161 : unit} =
    assert(dim_match_8160, {"Value of (core language) shape (", d<{(*) num_threads e}>_8155 : i64, ") cannot match shape of type `[", num_elems_7077 : i64, "]i64`."}, "../thesis-cuda/radix-fut/radix.fut:53:24-68:41")
  let {bounds_invalid_upwards_8298 : bool} =
    slt64(num_threads_7078, 0i64)
  let {valid_8299 : bool} =
    not bounds_invalid_upwards_8298
  let {range_valid_c_8300 : unit} =
    assert(valid_8299, {"Range ", 0i64 : i64, "..", 1i64 : i64, "..<", num_threads_7078 : i64, " is invalid."}, "/prelude/array.fut:82:3-11")
  let {empty_slice_8309 : bool} =
    eq_i64(d<{(-) num_threads 1}>_8156, 0i64)
  let {m_8310 : i64} =
    sub64(d<{(-) num_threads 1}>_8156, 1i64)
  let {zero_leq_i_p_m_t_s_8311 : bool} =
    sle64(0i64, m_8310)
  let {i_p_m_t_s_leq_w_8312 : bool} =
    slt64(m_8310, num_threads_7078)
  let {i_lte_j_8313 : bool} =
    sle64(0i64, d<{(-) num_threads 1}>_8156)
  let {y_8314 : bool} =
    logand(zero_leq_i_p_m_t_s_8311, i_p_m_t_s_leq_w_8312)
  let {forwards_ok_8315 : bool} =
    logand(i_lte_j_8313, y_8314)
  let {ok_or_empty_8316 : bool} =
    logor(empty_slice_8309, forwards_ok_8315)
  let {index_certs_8317 : unit} =
    assert(ok_or_empty_8316, {"Index [", 0i64 : i64, ":", d<{(-) num_threads 1}>_8156 : i64, "] out of bounds for array of shape [", num_threads_7078 : i64, "]."}, "/prelude/array.fut:36:37-45")
  let {suff_outer_par_8589 : bool} =
    cmp_size(suff_outer_par_0, threshold(def, )) <= num_blocks_7076
  let {y_8584 : i64} =
    smin64(num_elems_7077, d<{(*) num_threads e}>_8155)
  let {intra_avail_par_8585 : i64} =
    smin64(num_threads_7078, y_8584)
  let {y_8586 : i64} =
    smax64(num_elems_7077, d<{(*) num_threads e}>_8155)
  let {computed_group_size_8500 : i64} =
    smax64(num_threads_7078, y_8586)
  let {max_group_size_8833 : i64} =
    get_size_max(group_size)
  let {fits_8834 : bool} =
    sle64(computed_group_size_8500, max_group_size_8833)
  let {suff_intra_par_8832 : bool} =
    cmp_size(suff_intra_par_1, threshold(32, !suff_outer_par_0)) <= intra_avail_par_8585
  let {intra_suff_and_fits_8835 : bool} =
    logand(suff_intra_par_8832, fits_8834)
  let {suff_outer_par_10032 : bool} =
    cmp_size(suff_outer_par_2, threshold(def, !suff_outer_par_0 !suff_intra_par_1)) <= num_blocks_7076
  let {suff_intra_par_10043 : bool} =
    cmp_size(suff_intra_par_3, threshold(32, !suff_outer_par_2 !suff_outer_par_0 !suff_intra_par_1)) <= intra_avail_par_8585
  let {intra_suff_and_fits_10044 : bool} =
    logand(fits_8834, suff_intra_par_10043)
  let {nest_size_10291 : i64} =
    mul_nw64(num_blocks_7076, num_threads_7078)
  let {segscan_group_size_10292 : i64} =
    get_size(segscan_group_size_9736, group_size)
  let {num_groups_10293 : i64} =
    calc_num_groups(nest_size_10291, segscan_num_groups_9738, segscan_group_size_10292)
  let {segred_group_size_10340 : i64} =
    get_size(segred_group_size_9718, group_size)
  let {num_groups_10341 : i64} =
    calc_num_groups(nest_size_10291, segred_num_groups_9720, segred_group_size_10340)
  let {segmap_group_size_10353 : i64} =
    get_size(segmap_group_size_9700, group_size)
  let {num_groups_10354 : i64} =
    calc_num_groups(num_blocks_7076, segmap_num_groups_9702, segmap_group_size_10353)
  let {segmap_group_size_10373 : i64} =
    get_size(segmap_group_size_9558, group_size)
  let {segmap_group_size_10433 : i64} =
    get_size(segmap_group_size_9481, group_size)
  let {num_groups_10434 : i64} =
    calc_num_groups(nest_size_10291, segmap_num_groups_9483, segmap_group_size_10433)
  let {nest_size_10471 : i64} =
    mul_nw64(num_blocks_7076, num_elems_7077)
  let {segmap_group_size_10472 : i64} =
    get_size(segmap_group_size_9441, group_size)
  let {segmap_group_size_10047 : i64} =
    get_size(segmap_group_size_9076, group_size)
  let {num_groups_10048 : i64} =
    calc_num_groups(num_blocks_7076, segmap_num_groups_9078, segmap_group_size_10047)
  let {segmap_group_size_8713 : i64} =
    get_size(segmap_group_size_8593, group_size)
  let {num_groups_8714 : i64} =
    calc_num_groups(num_blocks_7076, segmap_num_groups_8595, segmap_group_size_8713)
  let {segmap_usable_groups_10374 : i64} =
    sdiv_up_safe64(nest_size_10291, segmap_group_size_10373)
  let {segmap_usable_groups_10473 : i64} =
    sdiv_up_safe64(nest_size_10471, segmap_group_size_10472)
  let {defunc_0_map_res_8497 : [num_blocks_7076][num_elems_7077]i32} =
    if <equiv> suff_outer_par_8589
    then {
      let {arr_coalesced_10581 : [num_blocks_7076][num_elems_7077]i32} =
        manifest((1, 0), arr_7081)
      let {defunc_0_map_res_8716 : [num_blocks_7076][num_elems_7077]i32} =
        segmap(thread; virtualise; groups=num_groups_8714; groupsize=segmap_group_size_8713)
        (gtid_8717 < num_blocks_7076) (~phys_tid_8718) : {[num_elems_7077]i32} {
          let {sh_tile_8724 : [num_elems_7077]i32} =
            arr_coalesced_10581[gtid_8717, 0i64 :+ num_elems_7077 * 1i64]
          let {lifted_lambda_res_8725 : [num_elems_7077]i32} =
            loop {sh_tile_8727 : [num_elems_7077]i32} = {sh_tile_8724}
            for k_8726:i32 < 4i32 do {
              let {result_10589 : [num_threads_7078]i64} =
                scratch(i64, num_threads_7078)
              let {result_10590 : [num_threads_7078]i64} =
                scratch(i64, num_threads_7078)
              let {discard_10598 : i64,
                   defunc_0_scan_res_8728 : [num_threads_7078]i64,
                   defunc_0_reduce_res_8729 : i64,
                   defunc_0_map_res_8730 : [num_threads_7078]i64} =
                loop {scanacc_10591 : i64,
                      scanout_10592 : *[num_threads_7078]i64,
                      redout_10593 : i64,
                      mapout_10594 : *[num_threads_7078]i64} = {0i64, result_10589, 0i64, result_10590}
                for i_10595:i64 < num_threads_7078 do {
                  let {chunk_8738 : i64} =
                    #{range_valid_c_8300}
                    mul64(e_7079, i_10595)
                  let {*_lhs_8739 : i64} =
                    #{range_valid_c_8300}
                    add64(1i64, i_10595)
                  let {chunk_8740 : i64} =
                    mul64(e_7079, *_lhs_8739)
                  let {j_m_i_8741 : i64} =
                    sub64(chunk_8740, chunk_8738)
                  let {empty_slice_8742 : bool} =
                    eq_i64(j_m_i_8741, 0i64)
                  let {m_8743 : i64} =
                    sub64(j_m_i_8741, 1i64)
                  let {i_p_m_t_s_8744 : i64} =
                    add64(chunk_8738, m_8743)
                  let {zero_leq_i_p_m_t_s_8745 : bool} =
                    sle64(0i64, i_p_m_t_s_8744)
                  let {i_p_m_t_s_leq_w_8746 : bool} =
                    slt64(i_p_m_t_s_8744, num_elems_7077)
                  let {zero_lte_i_8747 : bool} =
                    sle64(0i64, chunk_8738)
                  let {i_lte_j_8748 : bool} =
                    sle64(chunk_8738, chunk_8740)
                  let {y_8749 : bool} =
                    logand(i_p_m_t_s_leq_w_8746, zero_lte_i_8747)
                  let {y_8750 : bool} =
                    logand(zero_leq_i_p_m_t_s_8745, y_8749)
                  let {forwards_ok_8751 : bool} =
                    logand(i_lte_j_8748, y_8750)
                  let {ok_or_empty_8752 : bool} =
                    logor(empty_slice_8742, forwards_ok_8751)
                  let {index_certs_8753 : unit} =
                    assert(ok_or_empty_8752, {"Index [", chunk_8738 : i64, ":", chunk_8740 : i64, "] out of bounds for array of shape [", num_elems_7077 : i64, "]."}, "../thesis-cuda/radix-fut/radix.fut:30:29-55")
                  let {lifted_lambda_res_8754 : i64,
                       lifted_lambda_res_8755 : i64} =
                    loop {b0_8757 : i64,
                          b1_8758 : i64} = {0i64, 0i64}
                    for i_8756:i64 < e_7079 do {
                      let {y_8759 : bool} =
                        slt64(i_8756, j_m_i_8741)
                      let {index_certs_8760 : unit} =
                        assert(y_8759, {"Index [", i_8756 : i64, "] out of bounds for array of shape [", j_m_i_8741 : i64, "]."}, "../thesis-cuda/radix-fut/radix.fut:34:36-44")
                      let {slice_8761 : i64} =
                        #{index_certs_8760}
                        add_nw64(chunk_8738, i_8756)
                      let {elem_8762 : i32} =
                        #{index_certs_8753, index_certs_8760}
                        sh_tile_8727[slice_8761]
                      let {unsign_arg0_8763 : i32} =
                        ashr32(elem_8762, k_8726)
                      let {unsign_arg0_8764 : i32} =
                        and32(1i32, unsign_arg0_8763)
                      let {cond_8765 : bool} =
                        eq_i32(unsign_arg0_8764, 0i32)
                      let {loopres_8766 : i64,
                           loopres_8767 : i64} =
                        if cond_8765
                        then {
                          let {tmp_8768 : i64} =
                            add64(1i64, b0_8757)
                          in {tmp_8768, b1_8758}
                        } else {
                          let {tmp_8769 : i64} =
                            add64(1i64, b1_8758)
                          in {b0_8757, tmp_8769}
                        }
                        : {i64,
                           i64}
                      in {loopres_8766, loopres_8767}
                    }
                  let {defunc_0_op_res_8733 : i64} =
                    add64(lifted_lambda_res_8754, scanacc_10591)
                  let {defunc_0_op_res_8736 : i64} =
                    add64(lifted_lambda_res_8754, redout_10593)
                  let {lw_dest_10596 : [num_threads_7078]i64} =
                    scanout_10592 with [i_10595] = defunc_0_op_res_8733
                  let {lw_dest_10597 : [num_threads_7078]i64} =
                    mapout_10594 with [i_10595] = lifted_lambda_res_8755
                  in {defunc_0_op_res_8733, lw_dest_10596, defunc_0_op_res_8736, lw_dest_10597}
                }
              let {result_10599 : [num_threads_7078]i64} =
                scratch(i64, num_threads_7078)
              let {discard_10604 : i64,
                   defunc_0_scan_res_8770 : [num_threads_7078]i64} =
                loop {scanacc_10600 : i64,
                      scanout_10601 : *[num_threads_7078]i64} = {defunc_0_reduce_res_8729, result_10599}
                for i_10602:i64 < num_threads_7078 do {
                  let {x_8774 : i64} =
                    defunc_0_map_res_8730[i_10602]
                  let {defunc_0_op_res_8773 : i64} =
                    add64(x_8774, scanacc_10600)
                  let {lw_dest_10603 : [num_threads_7078]i64} =
                    scanout_10601 with [i_10602] = defunc_0_op_res_8773
                  in {defunc_0_op_res_8773, lw_dest_10603}
                }
              let {result_10605 : [num_threads_7078][e_7079]i64} =
                scratch(i64, num_threads_7078, e_7079)
              let {defunc_0_map_res_8775 : [num_threads_7078][e_7079]i64} =
                loop {mapout_10606 : *[num_threads_7078][e_7079]i64} = {result_10605}
                for i_10607:i64 < num_threads_7078 do {
                  let {chunk_8777 : i64} =
                    #{range_valid_c_8300}
                    mul64(e_7079, i_10607)
                  let {*_lhs_8778 : i64} =
                    #{range_valid_c_8300}
                    add64(1i64, i_10607)
                  let {chunk_8779 : i64} =
                    mul64(e_7079, *_lhs_8778)
                  let {j_m_i_8780 : i64} =
                    sub64(chunk_8779, chunk_8777)
                  let {empty_slice_8781 : bool} =
                    eq_i64(j_m_i_8780, 0i64)
                  let {m_8782 : i64} =
                    sub64(j_m_i_8780, 1i64)
                  let {i_p_m_t_s_8783 : i64} =
                    add64(chunk_8777, m_8782)
                  let {zero_leq_i_p_m_t_s_8784 : bool} =
                    sle64(0i64, i_p_m_t_s_8783)
                  let {i_p_m_t_s_leq_w_8785 : bool} =
                    slt64(i_p_m_t_s_8783, num_elems_7077)
                  let {zero_lte_i_8786 : bool} =
                    sle64(0i64, chunk_8777)
                  let {i_lte_j_8787 : bool} =
                    sle64(chunk_8777, chunk_8779)
                  let {y_8788 : bool} =
                    logand(i_p_m_t_s_leq_w_8785, zero_lte_i_8786)
                  let {y_8789 : bool} =
                    logand(zero_leq_i_p_m_t_s_8784, y_8788)
                  let {forwards_ok_8790 : bool} =
                    logand(i_lte_j_8787, y_8789)
                  let {ok_or_empty_8791 : bool} =
                    logor(empty_slice_8781, forwards_ok_8790)
                  let {index_certs_8792 : unit} =
                    assert(ok_or_empty_8791, {"Index [", chunk_8777 : i64, ":", chunk_8779 : i64, "] out of bounds for array of shape [", num_elems_7077 : i64, "]."}, "../thesis-cuda/radix-fut/radix.fut:55:29-55")
                  let {index_concat_cmp_8797 : bool} =
                    #{range_valid_c_8300}
                    sle64(1i64, i_10607)
                  let {index_concat_branch_8798 : i64} =
                    #{range_valid_c_8300}
                    if index_concat_cmp_8797
                    then {
                      let {index_concat_i_8799 : i64} =
                        #{range_valid_c_8300}
                        sub64(i_10607, 1i64)
                      let {index_concat_8800 : i64} =
                        #{index_certs_8317}
                        defunc_0_scan_res_8728[index_concat_i_8799]
                      in {index_concat_8800}
                    } else {0i64}
                    : {i64}
                  let {index_concat_branch_8801 : i64} =
                    #{range_valid_c_8300}
                    if index_concat_cmp_8797
                    then {
                      let {index_concat_i_8802 : i64} =
                        #{range_valid_c_8300}
                        sub64(i_10607, 1i64)
                      let {index_concat_8803 : i64} =
                        #{index_certs_8317}
                        defunc_0_scan_res_8770[index_concat_i_8802]
                      in {index_concat_8803}
                    } else {defunc_0_reduce_res_8729}
                    : {i64}
                  let {defunc_0_map_res_8804 : [e_7079]i64} =
                    replicate([e_7079], 0i64)
                  let {idxs_8805 : [e_7079]i64,
                       idxs_8806 : i64,
                       idxs_8807 : i64} =
                    loop {idxs_8809 : *[e_7079]i64,
                          b0_8810 : i64,
                          b1_8811 : i64} = {defunc_0_map_res_8804, index_concat_branch_8798, index_concat_branch_8801}
                    for i_8808:i64 < e_7079 do {
                      let {y_8812 : bool} =
                        slt64(i_8808, j_m_i_8780)
                      let {index_certs_8813 : unit} =
                        assert(y_8812, {"Index [", i_8808 : i64, "] out of bounds for array of shape [", j_m_i_8780 : i64, "]."}, "../thesis-cuda/radix-fut/radix.fut:60:36-44")
                      let {slice_8814 : i64} =
                        #{index_certs_8813}
                        add_nw64(chunk_8777, i_8808)
                      let {elem_8815 : i32} =
                        #{index_certs_8792, index_certs_8813}
                        sh_tile_8727[slice_8814]
                      let {unsign_arg0_8816 : i32} =
                        ashr32(elem_8815, k_8726)
                      let {unsign_arg0_8817 : i32} =
                        and32(1i32, unsign_arg0_8816)
                      let {cond_8818 : bool} =
                        eq_i32(unsign_arg0_8817, 0i32)
                      let {loopres_8819 : [e_7079]i64,
                           loopres_8820 : i64,
                           loopres_8821 : i64} =
                        if cond_8818
                        then {
                          let {tmp_8822 : [e_7079]i64} =
                            idxs_8809 with [i_8808] = b0_8810
                          let {tmp_8823 : i64} =
                            add64(1i64, b0_8810)
                          in {tmp_8822, tmp_8823, b1_8811}
                        } else {
                          let {tmp_8824 : [e_7079]i64} =
                            idxs_8809 with [i_8808] = b1_8811
                          let {tmp_8825 : i64} =
                            add64(1i64, b1_8811)
                          in {tmp_8824, b0_8810, tmp_8825}
                        }
                        : {[e_7079]i64,
                           i64,
                           i64}
                      in {loopres_8819, loopres_8820, loopres_8821}
                    }
                  let {lw_dest_10608 : [num_threads_7078][e_7079]i64} =
                    mapout_10606 with [i_10607, 0i64 :+ e_7079 * 1i64] = idxs_8805
                  in {lw_dest_10608}
                }
              let {smaller_replicate_8826 : [num_elems_7077]i32} =
                copy(sh_tile_8727)
              let {scatter_res_8828 : [num_elems_7077]i32} =
                loop {write_out_10610 : *[num_elems_7077]i32} = {smaller_replicate_8826}
                for write_iter_10609:i64 < num_elems_7077 do {
                  let {new_index_10665 : i64} =
                    squot64(write_iter_10609, e_7079)
                  let {binop_y_10667 : i64} =
                    mul_nw64(e_7079, new_index_10665)
                  let {new_index_10668 : i64} =
                    sub_nw64(write_iter_10609, binop_y_10667)
                  let {write_iv_10611 : i64} =
                    #{empty_or_match_cert_8161}
                    defunc_0_map_res_8775[new_index_10665, new_index_10668]
                  let {write_iv_slice_10669 : [1i64]i32} =
                    sh_tile_8727[write_iter_10609 :+ 1i64 * 1i64]
                  let {write_out_10613 : [num_elems_7077]i32} =
                    write_out_10610 with? [write_iv_10611 :+ 1i64 * 1i64] = write_iv_slice_10669
                  in {write_out_10613}
                }
              in {scatter_res_8828}
            }
          return {returns lifted_lambda_res_8725}
        }
      in {defunc_0_map_res_8716}
    } else {
      let {defunc_0_map_res_10481 : [num_blocks_7076][num_elems_7077]i32} =
        if <equiv> intra_suff_and_fits_8835
        then {
          let {defunc_0_map_res_8836 : [num_blocks_7076][num_elems_7077]i32} =
            segmap(group; ; groups=num_blocks_7076; groupsize=computed_group_size_8500)
            (gtid_8837 < num_blocks_7076) (~phys_group_id_8838) : {[num_elems_7077]i32} {
              let {sh_tile_8844 : [num_elems_7077]i32} =
                arr_7081[gtid_8837, 0i64 :+ num_elems_7077 * 1i64]
              let {lifted_lambda_res_8845 : [num_elems_7077]i32} =
                loop {sh_tile_8847 : [num_elems_7077]i32} = {sh_tile_8844}
                for k_8846:i32 < 4i32 do {
                  let {result_10614 : [num_threads_7078]i64} =
                    scratch(i64, num_threads_7078)
                  let {result_10615 : [num_threads_7078]i64} =
                    scratch(i64, num_threads_7078)
                  let {discard_10623 : i64,
                       defunc_0_scan_res_8848 : [num_threads_7078]i64,
                       defunc_0_reduce_res_8849 : i64,
                       defunc_0_map_res_8850 : [num_threads_7078]i64} =
                    loop {scanacc_10616 : i64,
                          scanout_10617 : *[num_threads_7078]i64,
                          redout_10618 : i64,
                          mapout_10619 : *[num_threads_7078]i64} = {0i64, result_10614, 0i64, result_10615}
                    for i_10620:i64 < num_threads_7078 do {
                      let {chunk_8858 : i64} =
                        #{range_valid_c_8300}
                        mul64(e_7079, i_10620)
                      let {*_lhs_8859 : i64} =
                        #{range_valid_c_8300}
                        add64(1i64, i_10620)
                      let {chunk_8860 : i64} =
                        mul64(e_7079, *_lhs_8859)
                      let {j_m_i_8861 : i64} =
                        sub64(chunk_8860, chunk_8858)
                      let {empty_slice_8862 : bool} =
                        eq_i64(j_m_i_8861, 0i64)
                      let {m_8863 : i64} =
                        sub64(j_m_i_8861, 1i64)
                      let {i_p_m_t_s_8864 : i64} =
                        add64(chunk_8858, m_8863)
                      let {zero_leq_i_p_m_t_s_8865 : bool} =
                        sle64(0i64, i_p_m_t_s_8864)
                      let {i_p_m_t_s_leq_w_8866 : bool} =
                        slt64(i_p_m_t_s_8864, num_elems_7077)
                      let {zero_lte_i_8867 : bool} =
                        sle64(0i64, chunk_8858)
                      let {i_lte_j_8868 : bool} =
                        sle64(chunk_8858, chunk_8860)
                      let {y_8869 : bool} =
                        logand(i_p_m_t_s_leq_w_8866, zero_lte_i_8867)
                      let {y_8870 : bool} =
                        logand(zero_leq_i_p_m_t_s_8865, y_8869)
                      let {forwards_ok_8871 : bool} =
                        logand(i_lte_j_8868, y_8870)
                      let {ok_or_empty_8872 : bool} =
                        logor(empty_slice_8862, forwards_ok_8871)
                      let {index_certs_8873 : unit} =
                        assert(ok_or_empty_8872, {"Index [", chunk_8858 : i64, ":", chunk_8860 : i64, "] out of bounds for array of shape [", num_elems_7077 : i64, "]."}, "../thesis-cuda/radix-fut/radix.fut:30:29-55")
                      let {lifted_lambda_res_8874 : i64,
                           lifted_lambda_res_8875 : i64} =
                        loop {b0_8877 : i64,
                              b1_8878 : i64} = {0i64, 0i64}
                        for i_8876:i64 < e_7079 do {
                          let {y_8879 : bool} =
                            slt64(i_8876, j_m_i_8861)
                          let {index_certs_8880 : unit} =
                            assert(y_8879, {"Index [", i_8876 : i64, "] out of bounds for array of shape [", j_m_i_8861 : i64, "]."}, "../thesis-cuda/radix-fut/radix.fut:34:36-44")
                          let {slice_8881 : i64} =
                            #{index_certs_8880}
                            add_nw64(chunk_8858, i_8876)
                          let {elem_8882 : i32} =
                            #{index_certs_8873, index_certs_8880}
                            sh_tile_8847[slice_8881]
                          let {unsign_arg0_8883 : i32} =
                            ashr32(elem_8882, k_8846)
                          let {unsign_arg0_8884 : i32} =
                            and32(1i32, unsign_arg0_8883)
                          let {cond_8885 : bool} =
                            eq_i32(unsign_arg0_8884, 0i32)
                          let {loopres_8886 : i64,
                               loopres_8887 : i64} =
                            if cond_8885
                            then {
                              let {tmp_8888 : i64} =
                                add64(1i64, b0_8877)
                              in {tmp_8888, b1_8878}
                            } else {
                              let {tmp_8889 : i64} =
                                add64(1i64, b1_8878)
                              in {b0_8877, tmp_8889}
                            }
                            : {i64,
                               i64}
                          in {loopres_8886, loopres_8887}
                        }
                      let {defunc_0_op_res_8853 : i64} =
                        add64(lifted_lambda_res_8874, scanacc_10616)
                      let {defunc_0_op_res_8856 : i64} =
                        add64(lifted_lambda_res_8874, redout_10618)
                      let {lw_dest_10621 : [num_threads_7078]i64} =
                        scanout_10617 with [i_10620] = defunc_0_op_res_8853
                      let {lw_dest_10622 : [num_threads_7078]i64} =
                        mapout_10619 with [i_10620] = lifted_lambda_res_8875
                      in {defunc_0_op_res_8853, lw_dest_10621, defunc_0_op_res_8856, lw_dest_10622}
                    }
                  let {defunc_0_scan_res_8890 : [num_threads_7078]i64} =
                    segscan(thread; ; )
                    (gtid_8891 < num_threads_7078) (~phys_tid_8892)
                    ({defunc_0_reduce_res_8849},
                    ,
                    \ {eta_p_8893 : i64,
                       eta_p_8894 : i64}
                      : {i64} ->
                      let {defunc_0_op_res_8895 : i64} =
                        add64(eta_p_8893, eta_p_8894)
                      in {defunc_0_op_res_8895})
                    : {i64} {
                      let {x_8896 : i64} =
                        defunc_0_map_res_8850[gtid_8891]
                      return {returns x_8896}
                    }
                  let {chunk_r_8897 : [num_threads_7078]i64,
                       j_m_i_r_8898 : [num_threads_7078]i64,
                       index_certs_r_8899 : [num_threads_7078]unit,
                       index_concat_branch_r_8900 : [num_threads_7078]i64,
                       index_concat_branch_r_8901 : [num_threads_7078]i64} =
                    segmap(thread; ; )
                    (gtid_8902 < num_threads_7078) (~phys_tid_8903) : {i64, i64, unit, i64, i64} {
                      let {chunk_8905 : i64} =
                        #{range_valid_c_8300}
                        mul64(e_7079, gtid_8902)
                      let {*_lhs_8906 : i64} =
                        #{range_valid_c_8300}
                        add64(1i64, gtid_8902)
                      let {chunk_8907 : i64} =
                        mul64(e_7079, *_lhs_8906)
                      let {j_m_i_8908 : i64} =
                        sub64(chunk_8907, chunk_8905)
                      let {empty_slice_8909 : bool} =
                        eq_i64(j_m_i_8908, 0i64)
                      let {m_8910 : i64} =
                        sub64(j_m_i_8908, 1i64)
                      let {i_p_m_t_s_8911 : i64} =
                        add64(chunk_8905, m_8910)
                      let {zero_leq_i_p_m_t_s_8912 : bool} =
                        sle64(0i64, i_p_m_t_s_8911)
                      let {i_p_m_t_s_leq_w_8913 : bool} =
                        slt64(i_p_m_t_s_8911, num_elems_7077)
                      let {zero_lte_i_8914 : bool} =
                        sle64(0i64, chunk_8905)
                      let {i_lte_j_8915 : bool} =
                        sle64(chunk_8905, chunk_8907)
                      let {y_8916 : bool} =
                        logand(i_p_m_t_s_leq_w_8913, zero_lte_i_8914)
                      let {y_8917 : bool} =
                        logand(zero_leq_i_p_m_t_s_8912, y_8916)
                      let {forwards_ok_8918 : bool} =
                        logand(i_lte_j_8915, y_8917)
                      let {ok_or_empty_8919 : bool} =
                        logor(empty_slice_8909, forwards_ok_8918)
                      let {index_certs_8920 : unit} =
                        assert(ok_or_empty_8919, {"Index [", chunk_8905 : i64, ":", chunk_8907 : i64, "] out of bounds for array of shape [", num_elems_7077 : i64, "]."}, "../thesis-cuda/radix-fut/radix.fut:55:29-55")
                      let {index_concat_cmp_8925 : bool} =
                        #{range_valid_c_8300}
                        sle64(1i64, gtid_8902)
                      let {index_concat_branch_8926 : i64} =
                        #{range_valid_c_8300}
                        if index_concat_cmp_8925
                        then {
                          let {index_concat_i_8927 : i64} =
                            #{range_valid_c_8300}
                            sub64(gtid_8902, 1i64)
                          let {index_concat_8928 : i64} =
                            #{index_certs_8317}
                            defunc_0_scan_res_8848[index_concat_i_8927]
                          in {index_concat_8928}
                        } else {0i64}
                        : {i64}
                      let {index_concat_branch_8929 : i64} =
                        #{range_valid_c_8300}
                        if index_concat_cmp_8925
                        then {
                          let {index_concat_i_8930 : i64} =
                            #{range_valid_c_8300}
                            sub64(gtid_8902, 1i64)
                          let {index_concat_8931 : i64} =
                            #{index_certs_8317}
                            defunc_0_scan_res_8890[index_concat_i_8930]
                          in {index_concat_8931}
                        } else {defunc_0_reduce_res_8849}
                        : {i64}
                      return {returns chunk_8905,
                              returns j_m_i_8908,
                              returns index_certs_8920,
                              returns index_concat_branch_8929,
                              returns index_concat_branch_8926}
                    }
                  let {defunc_0_map_res_8937 : [num_threads_7078][e_7079]i64} =
                    segmap(thread; ; )
                    (gtid_8938 < num_threads_7078) (~phys_tid_8939) : {[e_7079]i64} {
                      let {index_primexp_10553 : i64} =
                        mul64(e_7079, gtid_8938)
                      let {binop_y_10545 : i64} =
                        add64(1i64, gtid_8938)
                      let {binop_x_10546 : i64} =
                        mul64(e_7079, binop_y_10545)
                      let {index_primexp_10550 : i64} =
                        sub64(binop_x_10546, index_primexp_10553)
                      let {index_certs_8942 : unit} =
                        index_certs_r_8899[gtid_8938]
                      let {smaller_replicate_10542 : [e_7079]i64} =
                        replicate([e_7079], 0i64)
                      let {index_concat_branch_8944 : i64} =
                        index_concat_branch_r_8900[gtid_8938]
                      let {index_concat_branch_8945 : i64} =
                        index_concat_branch_r_8901[gtid_8938]
                      let {idxs_8946 : [e_7079]i64,
                           idxs_8947 : i64,
                           idxs_8948 : i64} =
                        loop {idxs_8950 : *[e_7079]i64,
                              b0_8951 : i64,
                              b1_8952 : i64} = {smaller_replicate_10542, index_concat_branch_8945, index_concat_branch_8944}
                        for i_8949:i64 < e_7079 do {
                          let {y_8953 : bool} =
                            #{range_valid_c_8300}
                            slt64(i_8949, index_primexp_10550)
                          let {index_certs_8954 : unit} =
                            #{range_valid_c_8300}
                            assert(y_8953, {"Index [", i_8949 : i64, "] out of bounds for array of shape [", index_primexp_10550 : i64, "]."}, "../thesis-cuda/radix-fut/radix.fut:60:36-44")
                          let {slice_8955 : i64} =
                            #{range_valid_c_8300, index_certs_8954}
                            add_nw64(i_8949, index_primexp_10553)
                          let {elem_8956 : i32} =
                            #{index_certs_8942, index_certs_8954}
                            sh_tile_8847[slice_8955]
                          let {unsign_arg0_8957 : i32} =
                            ashr32(elem_8956, k_8846)
                          let {unsign_arg0_8958 : i32} =
                            and32(1i32, unsign_arg0_8957)
                          let {cond_8959 : bool} =
                            eq_i32(unsign_arg0_8958, 0i32)
                          let {loopres_8960 : [e_7079]i64,
                               loopres_8961 : i64,
                               loopres_8962 : i64} =
                            if cond_8959
                            then {
                              let {tmp_8963 : [e_7079]i64} =
                                idxs_8950 with [i_8949] = b0_8951
                              let {tmp_8964 : i64} =
                                add64(1i64, b0_8951)
                              in {tmp_8963, tmp_8964, b1_8952}
                            } else {
                              let {tmp_8965 : [e_7079]i64} =
                                idxs_8950 with [i_8949] = b1_8952
                              let {tmp_8966 : i64} =
                                add64(1i64, b1_8952)
                              in {tmp_8965, b0_8951, tmp_8966}
                            }
                            : {[e_7079]i64,
                               i64,
                               i64}
                          in {loopres_8960, loopres_8961, loopres_8962}
                        }
                      return {returns idxs_8946}
                    }
                  let {smaller_replicate_8967 : [num_elems_7077]i32} =
                    copy(sh_tile_8847)
                  let {scatter_res_8969 : [num_elems_7077]i32} =
                    segmap(thread; ; )
                    (write_i_8970 < num_elems_7077) (~phys_tid_8971) : {i32} {
                      let {new_index_10485 : i64} =
                        squot64(write_i_8970, e_7079)
                      let {binop_y_10487 : i64} =
                        mul_nw64(e_7079, new_index_10485)
                      let {new_index_10488 : i64} =
                        sub_nw64(write_i_8970, binop_y_10487)
                      let {write_index_8972 : i64} =
                        #{empty_or_match_cert_8161}
                        defunc_0_map_res_8937[new_index_10485, new_index_10488]
                      let {write_value_8973 : i32} =
                        sh_tile_8847[write_i_8970]
                      return {smaller_replicate_8967 : [num_elems_7077]
                              with ([write_index_8972] = write_value_8973)}
                    }
                  in {scatter_res_8969}
                }
              return {returns lifted_lambda_res_8845}
            }
          in {defunc_0_map_res_8836}
        } else {
          let {defunc_0_map_res_10027 : [num_blocks_7076][num_elems_7077]i32} =
            loop {sh_tile_expanded_10029 : *[num_blocks_7076][num_elems_7077]i32} = {arr_7081}
            for k_10028:i32 < 4i32 do {
              let {sh_tile_expanded_transformed_10030 : [num_blocks_7076][num_elems_7077]i32} =
                copy(sh_tile_expanded_10029)
              let {lifted_lambda_res_10045 : [num_blocks_7076][num_elems_7077]i32} =
                if <equiv> suff_outer_par_10032
                then {
                  let {sh_tile_expanded_coalesced_10582 : [num_blocks_7076][num_elems_7077]i32} =
                    manifest((1, 0), sh_tile_expanded_10029)
                  let {sh_tile_expanded_transformed_coalesced_10583 : [num_blocks_7076][num_elems_7077]i32} =
                    manifest((1, 0), sh_tile_expanded_10029)
                  let {lifted_lambda_res_10050 : [num_blocks_7076][num_elems_7077]i32} =
                    segmap(thread; virtualise; groups=num_groups_10048; groupsize=segmap_group_size_10047)
                    (gtid_10051 < num_blocks_7076) (~phys_tid_10052) : {[num_elems_7077]i32} {
                      let {sh_tile_expanded_transformed_row_10054 : [num_elems_7077]i32} =
                        sh_tile_expanded_transformed_coalesced_10583[gtid_10051, 0i64 :+ num_elems_7077 * 1i64]
                      let {result_10624 : [num_threads_7078]i64} =
                        scratch(i64, num_threads_7078)
                      let {result_10625 : [num_threads_7078]i64} =
                        scratch(i64, num_threads_7078)
                      let {discard_10633 : i64,
                           defunc_0_scan_res_10055 : [num_threads_7078]i64,
                           defunc_0_reduce_res_10056 : i64,
                           defunc_0_map_res_10057 : [num_threads_7078]i64} =
                        loop {scanacc_10626 : i64,
                              scanout_10627 : *[num_threads_7078]i64,
                              redout_10628 : i64,
                              mapout_10629 : *[num_threads_7078]i64} = {0i64, result_10624, 0i64, result_10625}
                        for i_10630:i64 < num_threads_7078 do {
                          let {chunk_10065 : i64} =
                            #{range_valid_c_8300}
                            mul64(e_7079, i_10630)
                          let {*_lhs_10066 : i64} =
                            #{range_valid_c_8300}
                            add64(1i64, i_10630)
                          let {chunk_10067 : i64} =
                            mul64(e_7079, *_lhs_10066)
                          let {j_m_i_10068 : i64} =
                            sub64(chunk_10067, chunk_10065)
                          let {empty_slice_10069 : bool} =
                            eq_i64(j_m_i_10068, 0i64)
                          let {m_10070 : i64} =
                            sub64(j_m_i_10068, 1i64)
                          let {i_p_m_t_s_10071 : i64} =
                            add64(chunk_10065, m_10070)
                          let {zero_leq_i_p_m_t_s_10072 : bool} =
                            sle64(0i64, i_p_m_t_s_10071)
                          let {i_p_m_t_s_leq_w_10073 : bool} =
                            slt64(i_p_m_t_s_10071, num_elems_7077)
                          let {zero_lte_i_10074 : bool} =
                            sle64(0i64, chunk_10065)
                          let {i_lte_j_10075 : bool} =
                            sle64(chunk_10065, chunk_10067)
                          let {y_10076 : bool} =
                            logand(i_p_m_t_s_leq_w_10073, zero_lte_i_10074)
                          let {y_10077 : bool} =
                            logand(zero_leq_i_p_m_t_s_10072, y_10076)
                          let {forwards_ok_10078 : bool} =
                            logand(i_lte_j_10075, y_10077)
                          let {ok_or_empty_10079 : bool} =
                            logor(empty_slice_10069, forwards_ok_10078)
                          let {index_certs_10080 : unit} =
                            assert(ok_or_empty_10079, {"Index [", chunk_10065 : i64, ":", chunk_10067 : i64, "] out of bounds for array of shape [", num_elems_7077 : i64, "]."}, "../thesis-cuda/radix-fut/radix.fut:30:29-55")
                          let {lifted_lambda_res_10081 : i64,
                               lifted_lambda_res_10082 : i64} =
                            loop {b0_10084 : i64,
                                  b1_10085 : i64} = {0i64, 0i64}
                            for i_10083:i64 < e_7079 do {
                              let {y_10086 : bool} =
                                slt64(i_10083, j_m_i_10068)
                              let {index_certs_10087 : unit} =
                                assert(y_10086, {"Index [", i_10083 : i64, "] out of bounds for array of shape [", j_m_i_10068 : i64, "]."}, "../thesis-cuda/radix-fut/radix.fut:34:36-44")
                              let {slice_10088 : i64} =
                                #{index_certs_10087}
                                add_nw64(chunk_10065, i_10083)
                              let {elem_10089 : i32} =
                                #{index_certs_10080, index_certs_10087}
                                sh_tile_expanded_coalesced_10582[gtid_10051, slice_10088]
                              let {unsign_arg0_10090 : i32} =
                                ashr32(elem_10089, k_10028)
                              let {unsign_arg0_10091 : i32} =
                                and32(1i32, unsign_arg0_10090)
                              let {cond_10092 : bool} =
                                eq_i32(unsign_arg0_10091, 0i32)
                              let {loopres_10093 : i64,
                                   loopres_10094 : i64} =
                                if cond_10092
                                then {
                                  let {tmp_10095 : i64} =
                                    add64(1i64, b0_10084)
                                  in {tmp_10095, b1_10085}
                                } else {
                                  let {tmp_10096 : i64} =
                                    add64(1i64, b1_10085)
                                  in {b0_10084, tmp_10096}
                                }
                                : {i64,
                                   i64}
                              in {loopres_10093, loopres_10094}
                            }
                          let {defunc_0_op_res_10060 : i64} =
                            add64(lifted_lambda_res_10081, scanacc_10626)
                          let {defunc_0_op_res_10063 : i64} =
                            add64(lifted_lambda_res_10081, redout_10628)
                          let {lw_dest_10631 : [num_threads_7078]i64} =
                            scanout_10627 with [i_10630] = defunc_0_op_res_10060
                          let {lw_dest_10632 : [num_threads_7078]i64} =
                            mapout_10629 with [i_10630] = lifted_lambda_res_10082
                          in {defunc_0_op_res_10060, lw_dest_10631, defunc_0_op_res_10063, lw_dest_10632}
                        }
                      let {result_10634 : [num_threads_7078]i64} =
                        scratch(i64, num_threads_7078)
                      let {discard_10639 : i64,
                           defunc_0_scan_res_10097 : [num_threads_7078]i64} =
                        loop {scanacc_10635 : i64,
                              scanout_10636 : *[num_threads_7078]i64} = {defunc_0_reduce_res_10056, result_10634}
                        for i_10637:i64 < num_threads_7078 do {
                          let {x_10101 : i64} =
                            defunc_0_map_res_10057[i_10637]
                          let {defunc_0_op_res_10100 : i64} =
                            add64(x_10101, scanacc_10635)
                          let {lw_dest_10638 : [num_threads_7078]i64} =
                            scanout_10636 with [i_10637] = defunc_0_op_res_10100
                          in {defunc_0_op_res_10100, lw_dest_10638}
                        }
                      let {result_10640 : [num_threads_7078][e_7079]i64} =
                        scratch(i64, num_threads_7078, e_7079)
                      let {defunc_0_map_res_10102 : [num_threads_7078][e_7079]i64} =
                        loop {mapout_10641 : *[num_threads_7078][e_7079]i64} = {result_10640}
                        for i_10642:i64 < num_threads_7078 do {
                          let {chunk_10104 : i64} =
                            #{range_valid_c_8300}
                            mul64(e_7079, i_10642)
                          let {*_lhs_10105 : i64} =
                            #{range_valid_c_8300}
                            add64(1i64, i_10642)
                          let {chunk_10106 : i64} =
                            mul64(e_7079, *_lhs_10105)
                          let {j_m_i_10107 : i64} =
                            sub64(chunk_10106, chunk_10104)
                          let {empty_slice_10108 : bool} =
                            eq_i64(j_m_i_10107, 0i64)
                          let {m_10109 : i64} =
                            sub64(j_m_i_10107, 1i64)
                          let {i_p_m_t_s_10110 : i64} =
                            add64(chunk_10104, m_10109)
                          let {zero_leq_i_p_m_t_s_10111 : bool} =
                            sle64(0i64, i_p_m_t_s_10110)
                          let {i_p_m_t_s_leq_w_10112 : bool} =
                            slt64(i_p_m_t_s_10110, num_elems_7077)
                          let {zero_lte_i_10113 : bool} =
                            sle64(0i64, chunk_10104)
                          let {i_lte_j_10114 : bool} =
                            sle64(chunk_10104, chunk_10106)
                          let {y_10115 : bool} =
                            logand(i_p_m_t_s_leq_w_10112, zero_lte_i_10113)
                          let {y_10116 : bool} =
                            logand(zero_leq_i_p_m_t_s_10111, y_10115)
                          let {forwards_ok_10117 : bool} =
                            logand(i_lte_j_10114, y_10116)
                          let {ok_or_empty_10118 : bool} =
                            logor(empty_slice_10108, forwards_ok_10117)
                          let {index_certs_10119 : unit} =
                            assert(ok_or_empty_10118, {"Index [", chunk_10104 : i64, ":", chunk_10106 : i64, "] out of bounds for array of shape [", num_elems_7077 : i64, "]."}, "../thesis-cuda/radix-fut/radix.fut:55:29-55")
                          let {index_concat_cmp_10124 : bool} =
                            #{range_valid_c_8300}
                            sle64(1i64, i_10642)
                          let {index_concat_branch_10125 : i64} =
                            #{range_valid_c_8300}
                            if index_concat_cmp_10124
                            then {
                              let {index_concat_i_10126 : i64} =
                                #{range_valid_c_8300}
                                sub64(i_10642, 1i64)
                              let {index_concat_10127 : i64} =
                                #{index_certs_8317}
                                defunc_0_scan_res_10055[index_concat_i_10126]
                              in {index_concat_10127}
                            } else {0i64}
                            : {i64}
                          let {index_concat_branch_10128 : i64} =
                            #{range_valid_c_8300}
                            if index_concat_cmp_10124
                            then {
                              let {index_concat_i_10129 : i64} =
                                #{range_valid_c_8300}
                                sub64(i_10642, 1i64)
                              let {index_concat_10130 : i64} =
                                #{index_certs_8317}
                                defunc_0_scan_res_10097[index_concat_i_10129]
                              in {index_concat_10130}
                            } else {defunc_0_reduce_res_10056}
                            : {i64}
                          let {defunc_0_map_res_10131 : [e_7079]i64} =
                            replicate([e_7079], 0i64)
                          let {idxs_10132 : [e_7079]i64,
                               idxs_10133 : i64,
                               idxs_10134 : i64} =
                            loop {idxs_10136 : *[e_7079]i64,
                                  b0_10137 : i64,
                                  b1_10138 : i64} = {defunc_0_map_res_10131, index_concat_branch_10125, index_concat_branch_10128}
                            for i_10135:i64 < e_7079 do {
                              let {y_10139 : bool} =
                                slt64(i_10135, j_m_i_10107)
                              let {index_certs_10140 : unit} =
                                assert(y_10139, {"Index [", i_10135 : i64, "] out of bounds for array of shape [", j_m_i_10107 : i64, "]."}, "../thesis-cuda/radix-fut/radix.fut:60:36-44")
                              let {slice_10141 : i64} =
                                #{index_certs_10140}
                                add_nw64(chunk_10104, i_10135)
                              let {elem_10142 : i32} =
                                #{index_certs_10119, index_certs_10140}
                                sh_tile_expanded_coalesced_10582[gtid_10051, slice_10141]
                              let {unsign_arg0_10143 : i32} =
                                ashr32(elem_10142, k_10028)
                              let {unsign_arg0_10144 : i32} =
                                and32(1i32, unsign_arg0_10143)
                              let {cond_10145 : bool} =
                                eq_i32(unsign_arg0_10144, 0i32)
                              let {loopres_10146 : [e_7079]i64,
                                   loopres_10147 : i64,
                                   loopres_10148 : i64} =
                                if cond_10145
                                then {
                                  let {tmp_10149 : [e_7079]i64} =
                                    idxs_10136 with [i_10135] = b0_10137
                                  let {tmp_10150 : i64} =
                                    add64(1i64, b0_10137)
                                  in {tmp_10149, tmp_10150, b1_10138}
                                } else {
                                  let {tmp_10151 : [e_7079]i64} =
                                    idxs_10136 with [i_10135] = b1_10138
                                  let {tmp_10152 : i64} =
                                    add64(1i64, b1_10138)
                                  in {tmp_10151, b0_10137, tmp_10152}
                                }
                                : {[e_7079]i64,
                                   i64,
                                   i64}
                              in {loopres_10146, loopres_10147, loopres_10148}
                            }
                          let {lw_dest_10643 : [num_threads_7078][e_7079]i64} =
                            mapout_10641 with [i_10642, 0i64 :+ e_7079 * 1i64] = idxs_10132
                          in {lw_dest_10643}
                        }
                      let {scatter_res_10154 : [num_elems_7077]i32} =
                        loop {write_out_10645 : *[num_elems_7077]i32} = {sh_tile_expanded_transformed_row_10054}
                        for write_iter_10644:i64 < num_elems_7077 do {
                          let {new_index_10676 : i64} =
                            squot64(write_iter_10644, e_7079)
                          let {binop_y_10678 : i64} =
                            mul_nw64(e_7079, new_index_10676)
                          let {new_index_10679 : i64} =
                            sub_nw64(write_iter_10644, binop_y_10678)
                          let {write_iv_10646 : i64} =
                            #{empty_or_match_cert_8161}
                            defunc_0_map_res_10102[new_index_10676, new_index_10679]
                          let {write_iv_slice_10680 : [1i64]i32} =
                            sh_tile_expanded_coalesced_10582[gtid_10051, write_iter_10644 :+ 1i64 * 1i64]
                          let {write_out_10648 : [num_elems_7077]i32} =
                            write_out_10645 with? [write_iv_10646 :+ 1i64 * 1i64] = write_iv_slice_10680
                          in {write_out_10648}
                        }
                      return {returns scatter_res_10154}
                    }
                  in {lifted_lambda_res_10050}
                } else {
                  let {lifted_lambda_res_10157 : [num_blocks_7076][num_elems_7077]i32} =
                    if <equiv> intra_suff_and_fits_10044
                    then {
                      let {lifted_lambda_res_10158 : [num_blocks_7076][num_elems_7077]i32} =
                        segmap(group; ; groups=num_blocks_7076; groupsize=computed_group_size_8500)
                        (gtid_10159 < num_blocks_7076) (~phys_group_id_10160) : {[num_elems_7077]i32} {
                          let {sh_tile_expanded_transformed_row_10163 : [num_elems_7077]i32} =
                            sh_tile_expanded_10029[gtid_10159, 0i64 :+ num_elems_7077 * 1i64]
                          let {sh_tile_expanded_transformed_row_10164 : [num_elems_7077]i32} =
                            copy(sh_tile_expanded_transformed_row_10163)
                          let {result_10649 : [num_threads_7078]i64} =
                            scratch(i64, num_threads_7078)
                          let {result_10650 : [num_threads_7078]i64} =
                            scratch(i64, num_threads_7078)
                          let {discard_10658 : i64,
                               defunc_0_scan_res_10165 : [num_threads_7078]i64,
                               defunc_0_reduce_res_10166 : i64,
                               defunc_0_map_res_10167 : [num_threads_7078]i64} =
                            loop {scanacc_10651 : i64,
                                  scanout_10652 : *[num_threads_7078]i64,
                                  redout_10653 : i64,
                                  mapout_10654 : *[num_threads_7078]i64} = {0i64, result_10649, 0i64, result_10650}
                            for i_10655:i64 < num_threads_7078 do {
                              let {chunk_10175 : i64} =
                                #{range_valid_c_8300}
                                mul64(e_7079, i_10655)
                              let {*_lhs_10176 : i64} =
                                #{range_valid_c_8300}
                                add64(1i64, i_10655)
                              let {chunk_10177 : i64} =
                                mul64(e_7079, *_lhs_10176)
                              let {j_m_i_10178 : i64} =
                                sub64(chunk_10177, chunk_10175)
                              let {empty_slice_10179 : bool} =
                                eq_i64(j_m_i_10178, 0i64)
                              let {m_10180 : i64} =
                                sub64(j_m_i_10178, 1i64)
                              let {i_p_m_t_s_10181 : i64} =
                                add64(chunk_10175, m_10180)
                              let {zero_leq_i_p_m_t_s_10182 : bool} =
                                sle64(0i64, i_p_m_t_s_10181)
                              let {i_p_m_t_s_leq_w_10183 : bool} =
                                slt64(i_p_m_t_s_10181, num_elems_7077)
                              let {zero_lte_i_10184 : bool} =
                                sle64(0i64, chunk_10175)
                              let {i_lte_j_10185 : bool} =
                                sle64(chunk_10175, chunk_10177)
                              let {y_10186 : bool} =
                                logand(i_p_m_t_s_leq_w_10183, zero_lte_i_10184)
                              let {y_10187 : bool} =
                                logand(zero_leq_i_p_m_t_s_10182, y_10186)
                              let {forwards_ok_10188 : bool} =
                                logand(i_lte_j_10185, y_10187)
                              let {ok_or_empty_10189 : bool} =
                                logor(empty_slice_10179, forwards_ok_10188)
                              let {index_certs_10190 : unit} =
                                assert(ok_or_empty_10189, {"Index [", chunk_10175 : i64, ":", chunk_10177 : i64, "] out of bounds for array of shape [", num_elems_7077 : i64, "]."}, "../thesis-cuda/radix-fut/radix.fut:30:29-55")
                              let {lifted_lambda_res_10191 : i64,
                                   lifted_lambda_res_10192 : i64} =
                                loop {b0_10194 : i64,
                                      b1_10195 : i64} = {0i64, 0i64}
                                for i_10193:i64 < e_7079 do {
                                  let {y_10196 : bool} =
                                    slt64(i_10193, j_m_i_10178)
                                  let {index_certs_10197 : unit} =
                                    assert(y_10196, {"Index [", i_10193 : i64, "] out of bounds for array of shape [", j_m_i_10178 : i64, "]."}, "../thesis-cuda/radix-fut/radix.fut:34:36-44")
                                  let {slice_10198 : i64} =
                                    #{index_certs_10197}
                                    add_nw64(chunk_10175, i_10193)
                                  let {elem_10199 : i32} =
                                    #{index_certs_10190, index_certs_10197}
                                    sh_tile_expanded_10029[gtid_10159, slice_10198]
                                  let {unsign_arg0_10200 : i32} =
                                    ashr32(elem_10199, k_10028)
                                  let {unsign_arg0_10201 : i32} =
                                    and32(1i32, unsign_arg0_10200)
                                  let {cond_10202 : bool} =
                                    eq_i32(unsign_arg0_10201, 0i32)
                                  let {loopres_10203 : i64,
                                       loopres_10204 : i64} =
                                    if cond_10202
                                    then {
                                      let {tmp_10205 : i64} =
                                        add64(1i64, b0_10194)
                                      in {tmp_10205, b1_10195}
                                    } else {
                                      let {tmp_10206 : i64} =
                                        add64(1i64, b1_10195)
                                      in {b0_10194, tmp_10206}
                                    }
                                    : {i64,
                                       i64}
                                  in {loopres_10203, loopres_10204}
                                }
                              let {defunc_0_op_res_10170 : i64} =
                                add64(lifted_lambda_res_10191, scanacc_10651)
                              let {defunc_0_op_res_10173 : i64} =
                                add64(lifted_lambda_res_10191, redout_10653)
                              let {lw_dest_10656 : [num_threads_7078]i64} =
                                scanout_10652 with [i_10655] = defunc_0_op_res_10170
                              let {lw_dest_10657 : [num_threads_7078]i64} =
                                mapout_10654 with [i_10655] = lifted_lambda_res_10192
                              in {defunc_0_op_res_10170, lw_dest_10656, defunc_0_op_res_10173, lw_dest_10657}
                            }
                          let {defunc_0_scan_res_10207 : [num_threads_7078]i64} =
                            segscan(thread; ; )
                            (gtid_10208 < num_threads_7078) (~phys_tid_10209)
                            ({defunc_0_reduce_res_10166},
                            ,
                            \ {eta_p_10210 : i64,
                               eta_p_10211 : i64}
                              : {i64} ->
                              let {defunc_0_op_res_10212 : i64} =
                                add64(eta_p_10210, eta_p_10211)
                              in {defunc_0_op_res_10212})
                            : {i64} {
                              let {x_10213 : i64} =
                                defunc_0_map_res_10167[gtid_10208]
                              return {returns x_10213}
                            }
                          let {chunk_r_10214 : [num_threads_7078]i64,
                               j_m_i_r_10215 : [num_threads_7078]i64,
                               index_certs_r_10216 : [num_threads_7078]unit,
                               index_concat_branch_r_10217 : [num_threads_7078]i64,
                               index_concat_branch_r_10218 : [num_threads_7078]i64} =
                            segmap(thread; ; )
                            (gtid_10219 < num_threads_7078) (~phys_tid_10220) : {i64, i64, unit, i64, i64} {
                              let {chunk_10222 : i64} =
                                #{range_valid_c_8300}
                                mul64(e_7079, gtid_10219)
                              let {*_lhs_10223 : i64} =
                                #{range_valid_c_8300}
                                add64(1i64, gtid_10219)
                              let {chunk_10224 : i64} =
                                mul64(e_7079, *_lhs_10223)
                              let {j_m_i_10225 : i64} =
                                sub64(chunk_10224, chunk_10222)
                              let {empty_slice_10226 : bool} =
                                eq_i64(j_m_i_10225, 0i64)
                              let {m_10227 : i64} =
                                sub64(j_m_i_10225, 1i64)
                              let {i_p_m_t_s_10228 : i64} =
                                add64(chunk_10222, m_10227)
                              let {zero_leq_i_p_m_t_s_10229 : bool} =
                                sle64(0i64, i_p_m_t_s_10228)
                              let {i_p_m_t_s_leq_w_10230 : bool} =
                                slt64(i_p_m_t_s_10228, num_elems_7077)
                              let {zero_lte_i_10231 : bool} =
                                sle64(0i64, chunk_10222)
                              let {i_lte_j_10232 : bool} =
                                sle64(chunk_10222, chunk_10224)
                              let {y_10233 : bool} =
                                logand(i_p_m_t_s_leq_w_10230, zero_lte_i_10231)
                              let {y_10234 : bool} =
                                logand(zero_leq_i_p_m_t_s_10229, y_10233)
                              let {forwards_ok_10235 : bool} =
                                logand(i_lte_j_10232, y_10234)
                              let {ok_or_empty_10236 : bool} =
                                logor(empty_slice_10226, forwards_ok_10235)
                              let {index_certs_10237 : unit} =
                                assert(ok_or_empty_10236, {"Index [", chunk_10222 : i64, ":", chunk_10224 : i64, "] out of bounds for array of shape [", num_elems_7077 : i64, "]."}, "../thesis-cuda/radix-fut/radix.fut:55:29-55")
                              let {index_concat_cmp_10242 : bool} =
                                #{range_valid_c_8300}
                                sle64(1i64, gtid_10219)
                              let {index_concat_branch_10243 : i64} =
                                #{range_valid_c_8300}
                                if index_concat_cmp_10242
                                then {
                                  let {index_concat_i_10244 : i64} =
                                    #{range_valid_c_8300}
                                    sub64(gtid_10219, 1i64)
                                  let {index_concat_10245 : i64} =
                                    #{index_certs_8317}
                                    defunc_0_scan_res_10165[index_concat_i_10244]
                                  in {index_concat_10245}
                                } else {0i64}
                                : {i64}
                              let {index_concat_branch_10246 : i64} =
                                #{range_valid_c_8300}
                                if index_concat_cmp_10242
                                then {
                                  let {index_concat_i_10247 : i64} =
                                    #{range_valid_c_8300}
                                    sub64(gtid_10219, 1i64)
                                  let {index_concat_10248 : i64} =
                                    #{index_certs_8317}
                                    defunc_0_scan_res_10207[index_concat_i_10247]
                                  in {index_concat_10248}
                                } else {defunc_0_reduce_res_10166}
                                : {i64}
                              return {returns chunk_10222,
                                      returns j_m_i_10225,
                                      returns index_certs_10237,
                                      returns index_concat_branch_10246,
                                      returns index_concat_branch_10243}
                            }
                          let {defunc_0_map_res_10254 : [num_threads_7078][e_7079]i64} =
                            segmap(thread; ; )
                            (gtid_10255 < num_threads_7078) (~phys_tid_10256) : {[e_7079]i64} {
                              let {index_primexp_10565 : i64} =
                                mul64(e_7079, gtid_10255)
                              let {binop_y_10557 : i64} =
                                add64(1i64, gtid_10255)
                              let {binop_x_10558 : i64} =
                                mul64(e_7079, binop_y_10557)
                              let {index_primexp_10562 : i64} =
                                sub64(binop_x_10558, index_primexp_10565)
                              let {index_certs_10259 : unit} =
                                index_certs_r_10216[gtid_10255]
                              let {smaller_replicate_10554 : [e_7079]i64} =
                                replicate([e_7079], 0i64)
                              let {index_concat_branch_10261 : i64} =
                                index_concat_branch_r_10217[gtid_10255]
                              let {index_concat_branch_10262 : i64} =
                                index_concat_branch_r_10218[gtid_10255]
                              let {idxs_10263 : [e_7079]i64,
                                   idxs_10264 : i64,
                                   idxs_10265 : i64} =
                                loop {idxs_10267 : *[e_7079]i64,
                                      b0_10268 : i64,
                                      b1_10269 : i64} = {smaller_replicate_10554, index_concat_branch_10262, index_concat_branch_10261}
                                for i_10266:i64 < e_7079 do {
                                  let {y_10270 : bool} =
                                    #{range_valid_c_8300}
                                    slt64(i_10266, index_primexp_10562)
                                  let {index_certs_10271 : unit} =
                                    #{range_valid_c_8300}
                                    assert(y_10270, {"Index [", i_10266 : i64, "] out of bounds for array of shape [", index_primexp_10562 : i64, "]."}, "../thesis-cuda/radix-fut/radix.fut:60:36-44")
                                  let {slice_10272 : i64} =
                                    #{range_valid_c_8300, index_certs_10271}
                                    add_nw64(i_10266, index_primexp_10565)
                                  let {elem_10273 : i32} =
                                    #{index_certs_10259, index_certs_10271}
                                    sh_tile_expanded_10029[gtid_10159, slice_10272]
                                  let {unsign_arg0_10274 : i32} =
                                    ashr32(elem_10273, k_10028)
                                  let {unsign_arg0_10275 : i32} =
                                    and32(1i32, unsign_arg0_10274)
                                  let {cond_10276 : bool} =
                                    eq_i32(unsign_arg0_10275, 0i32)
                                  let {loopres_10277 : [e_7079]i64,
                                       loopres_10278 : i64,
                                       loopres_10279 : i64} =
                                    if cond_10276
                                    then {
                                      let {tmp_10280 : [e_7079]i64} =
                                        idxs_10267 with [i_10266] = b0_10268
                                      let {tmp_10281 : i64} =
                                        add64(1i64, b0_10268)
                                      in {tmp_10280, tmp_10281, b1_10269}
                                    } else {
                                      let {tmp_10282 : [e_7079]i64} =
                                        idxs_10267 with [i_10266] = b1_10269
                                      let {tmp_10283 : i64} =
                                        add64(1i64, b1_10269)
                                      in {tmp_10282, b0_10268, tmp_10283}
                                    }
                                    : {[e_7079]i64,
                                       i64,
                                       i64}
                                  in {loopres_10277, loopres_10278, loopres_10279}
                                }
                              return {returns idxs_10263}
                            }
                          let {scatter_res_10285 : [num_elems_7077]i32} =
                            segmap(thread; ; )
                            (write_i_10286 < num_elems_7077) (~phys_tid_10287) : {i32} {
                              let {new_index_10493 : i64} =
                                squot64(write_i_10286, e_7079)
                              let {binop_y_10495 : i64} =
                                mul_nw64(e_7079, new_index_10493)
                              let {new_index_10496 : i64} =
                                sub_nw64(write_i_10286, binop_y_10495)
                              let {write_index_10288 : i64} =
                                #{empty_or_match_cert_8161}
                                defunc_0_map_res_10254[new_index_10493, new_index_10496]
                              let {write_value_10289 : i32} =
                                sh_tile_expanded_10029[gtid_10159, write_i_10286]
                              return {sh_tile_expanded_transformed_row_10164 : [num_elems_7077]
                                      with ([write_index_10288] = write_value_10289)}
                            }
                          return {returns scatter_res_10285}
                        }
                      in {lifted_lambda_res_10158}
                    } else {
                      let {defunc_0_scan_res_r_10295 : [num_blocks_7076][num_threads_7078]i64,
                           to_red_r_10296 : [num_blocks_7076][num_threads_7078]i64,
                           defunc_0_map_res_r_10297 : [num_blocks_7076][num_threads_7078]i64} =
                        segscan(thread; ; groups=num_groups_10293; groupsize=segscan_group_size_10292)
                        (gtid_10298 < num_blocks_7076, gtid_10299 < num_threads_7078) (~phys_tid_10300)
                        ({0i64},
                        ,
                        \ {eta_p_10301 : i64,
                           eta_p_10302 : i64}
                          : {i64} ->
                          let {defunc_0_op_res_10303 : i64} =
                            add64(eta_p_10301, eta_p_10302)
                          in {defunc_0_op_res_10303})
                        : {i64, i64, i64} {
                          let {chunk_10306 : i64} =
                            #{range_valid_c_8300}
                            mul64(e_7079, gtid_10299)
                          let {*_lhs_10307 : i64} =
                            #{range_valid_c_8300}
                            add64(1i64, gtid_10299)
                          let {chunk_10308 : i64} =
                            mul64(e_7079, *_lhs_10307)
                          let {j_m_i_10309 : i64} =
                            sub64(chunk_10308, chunk_10306)
                          let {empty_slice_10310 : bool} =
                            eq_i64(j_m_i_10309, 0i64)
                          let {m_10311 : i64} =
                            sub64(j_m_i_10309, 1i64)
                          let {i_p_m_t_s_10312 : i64} =
                            add64(chunk_10306, m_10311)
                          let {zero_leq_i_p_m_t_s_10313 : bool} =
                            sle64(0i64, i_p_m_t_s_10312)
                          let {i_p_m_t_s_leq_w_10314 : bool} =
                            slt64(i_p_m_t_s_10312, num_elems_7077)
                          let {zero_lte_i_10315 : bool} =
                            sle64(0i64, chunk_10306)
                          let {i_lte_j_10316 : bool} =
                            sle64(chunk_10306, chunk_10308)
                          let {y_10317 : bool} =
                            logand(i_p_m_t_s_leq_w_10314, zero_lte_i_10315)
                          let {y_10318 : bool} =
                            logand(zero_leq_i_p_m_t_s_10313, y_10317)
                          let {forwards_ok_10319 : bool} =
                            logand(i_lte_j_10316, y_10318)
                          let {ok_or_empty_10320 : bool} =
                            logor(empty_slice_10310, forwards_ok_10319)
                          let {index_certs_10321 : unit} =
                            assert(ok_or_empty_10320, {"Index [", chunk_10306 : i64, ":", chunk_10308 : i64, "] out of bounds for array of shape [", num_elems_7077 : i64, "]."}, "../thesis-cuda/radix-fut/radix.fut:30:29-55")
                          let {lifted_lambda_res_10322 : i64,
                               lifted_lambda_res_10323 : i64} =
                            loop {b0_10325 : i64,
                                  b1_10326 : i64} = {0i64, 0i64}
                            for i_10324:i64 < e_7079 do {
                              let {y_10327 : bool} =
                                slt64(i_10324, j_m_i_10309)
                              let {index_certs_10328 : unit} =
                                assert(y_10327, {"Index [", i_10324 : i64, "] out of bounds for array of shape [", j_m_i_10309 : i64, "]."}, "../thesis-cuda/radix-fut/radix.fut:34:36-44")
                              let {slice_10329 : i64} =
                                #{index_certs_10328}
                                add_nw64(chunk_10306, i_10324)
                              let {elem_10330 : i32} =
                                #{index_certs_10321, index_certs_10328}
                                sh_tile_expanded_10029[gtid_10298, slice_10329]
                              let {unsign_arg0_10331 : i32} =
                                ashr32(elem_10330, k_10028)
                              let {unsign_arg0_10332 : i32} =
                                and32(1i32, unsign_arg0_10331)
                              let {cond_10333 : bool} =
                                eq_i32(unsign_arg0_10332, 0i32)
                              let {loopres_10334 : i64,
                                   loopres_10335 : i64} =
                                if cond_10333
                                then {
                                  let {tmp_10336 : i64} =
                                    add64(1i64, b0_10325)
                                  in {tmp_10336, b1_10326}
                                } else {
                                  let {tmp_10337 : i64} =
                                    add64(1i64, b1_10326)
                                  in {b0_10325, tmp_10337}
                                }
                                : {i64,
                                   i64}
                              in {loopres_10334, loopres_10335}
                            }
                          return {returns lifted_lambda_res_10322,
                                  returns lifted_lambda_res_10322,
                                  returns lifted_lambda_res_10323}
                        }
                      let {defunc_0_reduce_res_r_10343 : [num_blocks_7076]i64} =
                        segred(thread; ; groups=num_groups_10341; groupsize=segred_group_size_10340)
                        (gtid_10344 < num_blocks_7076, gtid_10345 < num_threads_7078) (~phys_tid_10346)
                        ({0i64},
                        ,
                        commutative \ {eta_p_10347 : i64,
                                       eta_p_10348 : i64}
                          : {i64} ->
                          let {defunc_0_op_res_10349 : i64} =
                            add64(eta_p_10347, eta_p_10348)
                          in {defunc_0_op_res_10349})
                        : {i64} {
                          let {x_10351 : i64} =
                            to_red_r_10296[gtid_10344, gtid_10345]
                          return {returns x_10351}
                        }
                      let {defunc_0_map_res_r_coalesced_10586 : [num_blocks_7076][num_threads_7078]i64} =
                        manifest((1, 0), defunc_0_map_res_r_10297)
                      let {defunc_0_scan_res_r_10356 : [num_blocks_7076][num_threads_7078]i64} =
                        segmap(thread; virtualise; groups=num_groups_10354; groupsize=segmap_group_size_10353)
                        (gtid_10357 < num_blocks_7076) (~phys_tid_10358) : {[num_threads_7078]i64} {
                          let {defunc_0_reduce_res_10359 : i64} =
                            defunc_0_reduce_res_r_10343[gtid_10357]
                          let {result_10659 : [num_threads_7078]i64} =
                            scratch(i64, num_threads_7078)
                          let {discard_10664 : i64,
                               defunc_0_scan_res_10361 : [num_threads_7078]i64} =
                            loop {scanacc_10660 : i64,
                                  scanout_10661 : *[num_threads_7078]i64} = {defunc_0_reduce_res_10359, result_10659}
                            for i_10662:i64 < num_threads_7078 do {
                              let {x_10365 : i64} =
                                defunc_0_map_res_r_coalesced_10586[gtid_10357, i_10662]
                              let {defunc_0_op_res_10364 : i64} =
                                add64(x_10365, scanacc_10660)
                              let {lw_dest_10663 : [num_threads_7078]i64} =
                                scanout_10661 with [i_10662] = defunc_0_op_res_10364
                              in {defunc_0_op_res_10364, lw_dest_10663}
                            }
                          return {returns defunc_0_scan_res_10361}
                        }
                      let {defunc_0_scan_res_r_rowmajor_10587 : [num_blocks_7076][num_threads_7078]i64} =
                        manifest((0, 1), defunc_0_scan_res_r_10356)
                      let {chunk_r_r_10375 : [num_blocks_7076][num_threads_7078]i64,
                           j_m_i_r_r_10376 : [num_blocks_7076][num_threads_7078]i64,
                           index_certs_r_r_10377 : [num_blocks_7076][num_threads_7078]unit,
                           index_concat_branch_r_r_10378 : [num_blocks_7076][num_threads_7078]i64,
                           index_concat_branch_r_r_10379 : [num_blocks_7076][num_threads_7078]i64} =
                        segmap(thread; ; groups=segmap_usable_groups_10374; groupsize=segmap_group_size_10373)
                        (gtid_10380 < num_blocks_7076, gtid_10381 < num_threads_7078) (~phys_tid_10382) : {i64, i64, unit, i64, i64} {
                          let {chunk_10387 : i64} =
                            #{range_valid_c_8300}
                            mul64(e_7079, gtid_10381)
                          let {*_lhs_10388 : i64} =
                            #{range_valid_c_8300}
                            add64(1i64, gtid_10381)
                          let {chunk_10389 : i64} =
                            mul64(e_7079, *_lhs_10388)
                          let {j_m_i_10390 : i64} =
                            sub64(chunk_10389, chunk_10387)
                          let {empty_slice_10391 : bool} =
                            eq_i64(j_m_i_10390, 0i64)
                          let {m_10392 : i64} =
                            sub64(j_m_i_10390, 1i64)
                          let {i_p_m_t_s_10393 : i64} =
                            add64(chunk_10387, m_10392)
                          let {zero_leq_i_p_m_t_s_10394 : bool} =
                            sle64(0i64, i_p_m_t_s_10393)
                          let {i_p_m_t_s_leq_w_10395 : bool} =
                            slt64(i_p_m_t_s_10393, num_elems_7077)
                          let {zero_lte_i_10396 : bool} =
                            sle64(0i64, chunk_10387)
                          let {i_lte_j_10397 : bool} =
                            sle64(chunk_10387, chunk_10389)
                          let {y_10398 : bool} =
                            logand(i_p_m_t_s_leq_w_10395, zero_lte_i_10396)
                          let {y_10399 : bool} =
                            logand(zero_leq_i_p_m_t_s_10394, y_10398)
                          let {forwards_ok_10400 : bool} =
                            logand(i_lte_j_10397, y_10399)
                          let {ok_or_empty_10401 : bool} =
                            logor(empty_slice_10391, forwards_ok_10400)
                          let {index_certs_10402 : unit} =
                            assert(ok_or_empty_10401, {"Index [", chunk_10387 : i64, ":", chunk_10389 : i64, "] out of bounds for array of shape [", num_elems_7077 : i64, "]."}, "../thesis-cuda/radix-fut/radix.fut:55:29-55")
                          let {index_concat_cmp_10407 : bool} =
                            #{range_valid_c_8300}
                            sle64(1i64, gtid_10381)
                          let {index_concat_branch_10408 : i64} =
                            #{range_valid_c_8300}
                            if index_concat_cmp_10407
                            then {
                              let {index_concat_i_10409 : i64} =
                                #{range_valid_c_8300}
                                sub64(gtid_10381, 1i64)
                              let {index_concat_10410 : i64} =
                                #{index_certs_8317}
                                defunc_0_scan_res_r_10295[gtid_10380, index_concat_i_10409]
                              in {index_concat_10410}
                            } else {0i64}
                            : {i64}
                          let {index_concat_branch_10411 : i64} =
                            #{range_valid_c_8300}
                            if index_concat_cmp_10407
                            then {
                              let {index_concat_i_10412 : i64} =
                                #{range_valid_c_8300}
                                sub64(gtid_10381, 1i64)
                              let {index_concat_10413 : i64} =
                                #{index_certs_8317}
                                defunc_0_scan_res_r_rowmajor_10587[gtid_10380, index_concat_i_10412]
                              in {index_concat_10413}
                            } else {
                              let {defunc_0_reduce_res_10384 : i64} =
                                defunc_0_reduce_res_r_10343[gtid_10380]
                              in {defunc_0_reduce_res_10384}
                            }
                            : {i64}
                          return {returns chunk_10387,
                                  returns j_m_i_10390,
                                  returns index_certs_10402,
                                  returns index_concat_branch_10411,
                                  returns index_concat_branch_10408}
                        }
                      let {defunc_0_map_res_r_10436 : [num_blocks_7076][num_threads_7078][e_7079]i64} =
                        segmap(thread; virtualise; groups=num_groups_10434; groupsize=segmap_group_size_10433)
                        (gtid_10437 < num_blocks_7076, gtid_10438 < num_threads_7078) (~phys_tid_10439) : {[e_7079]i64} {
                          let {index_primexp_10577 : i64} =
                            mul64(e_7079, gtid_10438)
                          let {binop_y_10569 : i64} =
                            add64(1i64, gtid_10438)
                          let {binop_x_10570 : i64} =
                            mul64(e_7079, binop_y_10569)
                          let {index_primexp_10574 : i64} =
                            sub64(binop_x_10570, index_primexp_10577)
                          let {index_certs_10443 : unit} =
                            index_certs_r_r_10377[gtid_10437, gtid_10438]
                          let {smaller_replicate_10566 : [e_7079]i64} =
                            replicate([e_7079], 0i64)
                          let {index_concat_branch_10445 : i64} =
                            index_concat_branch_r_r_10378[gtid_10437, gtid_10438]
                          let {index_concat_branch_10446 : i64} =
                            index_concat_branch_r_r_10379[gtid_10437, gtid_10438]
                          let {idxs_10447 : [e_7079]i64,
                               idxs_10448 : i64,
                               idxs_10449 : i64} =
                            loop {idxs_10451 : *[e_7079]i64,
                                  b0_10452 : i64,
                                  b1_10453 : i64} = {smaller_replicate_10566, index_concat_branch_10446, index_concat_branch_10445}
                            for i_10450:i64 < e_7079 do {
                              let {y_10454 : bool} =
                                #{range_valid_c_8300}
                                slt64(i_10450, index_primexp_10574)
                              let {index_certs_10455 : unit} =
                                #{range_valid_c_8300}
                                assert(y_10454, {"Index [", i_10450 : i64, "] out of bounds for array of shape [", index_primexp_10574 : i64, "]."}, "../thesis-cuda/radix-fut/radix.fut:60:36-44")
                              let {slice_10456 : i64} =
                                #{range_valid_c_8300, index_certs_10455}
                                add_nw64(i_10450, index_primexp_10577)
                              let {elem_10457 : i32} =
                                #{index_certs_10443, index_certs_10455}
                                sh_tile_expanded_10029[gtid_10437, slice_10456]
                              let {unsign_arg0_10458 : i32} =
                                ashr32(elem_10457, k_10028)
                              let {unsign_arg0_10459 : i32} =
                                and32(1i32, unsign_arg0_10458)
                              let {cond_10460 : bool} =
                                eq_i32(unsign_arg0_10459, 0i32)
                              let {loopres_10461 : [e_7079]i64,
                                   loopres_10462 : i64,
                                   loopres_10463 : i64} =
                                if cond_10460
                                then {
                                  let {tmp_10464 : [e_7079]i64} =
                                    idxs_10451 with [i_10450] = b0_10452
                                  let {tmp_10465 : i64} =
                                    add64(1i64, b0_10452)
                                  in {tmp_10464, tmp_10465, b1_10453}
                                } else {
                                  let {tmp_10466 : [e_7079]i64} =
                                    idxs_10451 with [i_10450] = b1_10453
                                  let {tmp_10467 : i64} =
                                    add64(1i64, b1_10453)
                                  in {tmp_10466, b0_10452, tmp_10467}
                                }
                                : {[e_7079]i64,
                                   i64,
                                   i64}
                              in {loopres_10461, loopres_10462, loopres_10463}
                            }
                          return {returns idxs_10447}
                        }
                      let {defunc_0_map_res_r_rowmajor_10588 : [num_blocks_7076][num_threads_7078][e_7079]i64} =
                        manifest((0, 1, 2), defunc_0_map_res_r_10436)
                      let {lifted_lambda_res_10474 : [num_blocks_7076][num_elems_7077]i32} =
                        segmap(thread; ; groups=segmap_usable_groups_10473; groupsize=segmap_group_size_10472)
                        (gtid_10475 < num_blocks_7076, gtid_10476 < num_elems_7077) (~phys_tid_10477) : {i32} {
                          let {binop_x_10499 : i64} =
                            mul_nw64(num_elems_7077, gtid_10475)
                          let {binop_x_10500 : i64} =
                            add_nw64(gtid_10476, binop_x_10499)
                          let {new_index_10502 : i64} =
                            squot64(binop_x_10500, d<{(*) num_threads e}>_8155)
                          let {binop_y_10510 : i64} =
                            mul_nw64(d<{(*) num_threads e}>_8155, new_index_10502)
                          let {binop_x_10511 : i64} =
                            sub_nw64(binop_x_10500, binop_y_10510)
                          let {new_index_10512 : i64} =
                            squot64(binop_x_10511, e_7079)
                          let {binop_y_10532 : i64} =
                            mul_nw64(e_7079, new_index_10512)
                          let {new_index_10533 : i64} =
                            sub_nw64(binop_x_10511, binop_y_10532)
                          let {write_index_10478 : i64} =
                            #{empty_or_match_cert_8161}
                            defunc_0_map_res_r_rowmajor_10588[new_index_10502, new_index_10512, new_index_10533]
                          let {write_value_10479 : i32} =
                            sh_tile_expanded_10029[gtid_10475, gtid_10476]
                          return {sh_tile_expanded_transformed_10030 : [num_blocks_7076][num_elems_7077]
                                  with ([gtid_10475, write_index_10478] = write_value_10479)}
                        }
                      in {lifted_lambda_res_10474}
                    }
                    : {[num_blocks_7076][num_elems_7077]i32}
                  in {lifted_lambda_res_10157}
                }
                : {[num_blocks_7076][num_elems_7077]i32}
              in {lifted_lambda_res_10045}
            }
          in {defunc_0_map_res_10027}
        }
        : {[num_blocks_7076][num_elems_7077]i32}
      in {defunc_0_map_res_10481}
    }
    : {[num_blocks_7076][num_elems_7077]i32}
  in {defunc_0_map_res_8497}
}
